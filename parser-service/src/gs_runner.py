"""
Ghostscript runner module for parser-service.
Handles PDF plate extraction and TIFF→PNG conversion.
"""

import os
import subprocess
import logging
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any
from PIL import Image

# Handle both relative and absolute imports
try:
    from . import config
except ImportError:
    import config

logger = logging.getLogger("parser.ghostscript")


class GhostscriptError(Exception):
    """Base exception for Ghostscript operations."""
    pass


class GhostscriptTimeoutError(GhostscriptError):
    """Raised when Ghostscript operation times out."""
    pass


class PlateExtractor:
    """Handles PDF plate extraction using Ghostscript."""
    
    def __init__(self, gs_exe: Optional[str] = None):
        """
        Initialize plate extractor.
        
        Args:
            gs_exe: Path to Ghostscript executable (auto-detects if None)
        """
        if gs_exe:
            self.gs_exe = gs_exe
        else:
            try:
                self.gs_exe = config.get_ghostscript_path()
            except FileNotFoundError as e:
                raise GhostscriptError(str(e))
        
        logger.info(f"Using Ghostscript: {self.gs_exe}")
    
    def extract_plates(self, pdf_path: Path, output_dir: Path, 
                      dpi: int = None, timeout: int = None) -> List[Path]:
        """
        Extract all plates from PDF using tiffsep device.
        
        Args:
            pdf_path: Path to input PDF
            output_dir: Output directory for plate TIFFs
            dpi: Resolution in DPI (uses config default if None)
            timeout: Timeout in seconds (uses config default if None)
            
        Returns:
            List of generated plate TIFF paths
            
        Raises:
            GhostscriptError: If extraction fails
            GhostscriptTimeoutError: If extraction times out
        """
        if dpi is None:
            dpi = config.PLATE_DPI
        
        if timeout is None:
            timeout = config.GHOSTSCRIPT_TIMEOUT
        
        if not pdf_path.exists():
            raise GhostscriptError(f"PDF not found: {pdf_path}")
        
        # Create plates subdirectory
        plates_dir = output_dir / f"{pdf_path.stem}__plates"
        plates_dir.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"Extracting plates from: {pdf_path}")
        logger.info(f"Output dir: {plates_dir}")
        logger.info(f"DPI: {dpi}")
        
        # Ghostscript command for tiffsep
        # tiffsep device creates separate TIFF files for each plate
        output_pattern = str(plates_dir / "plate%04d.tif")
        
        cmd = [
            self.gs_exe,
            "-dNOPAUSE",
            "-dBATCH",
            "-dSAFER",
            f"-sDEVICE={config.GS_DEVICE}",
            f"-r{dpi}",
            "-dMaxBitmap=2147483647",
            f"-sOutputFile={output_pattern}",
            str(pdf_path)
        ]
        
        logger.debug(f"Running: {' '.join(cmd)}")
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                timeout=timeout,
                text=True
            )
            
            # Log output
            if result.stdout:
                logger.debug(f"stdout: {result.stdout}")
            if result.stderr:
                # Ghostscript often writes info to stderr
                logger.debug(f"stderr: {result.stderr}")
            
            if result.returncode != 0:
                raise GhostscriptError(
                    f"Ghostscript failed with return code {result.returncode}: {result.stderr}"
                )
        
        except subprocess.TimeoutExpired:
            raise GhostscriptTimeoutError(f"Ghostscript timed out after {timeout}s")
        except FileNotFoundError:
            raise GhostscriptError(f"Ghostscript executable not found: {self.gs_exe}")
        except Exception as e:
            raise GhostscriptError(f"Ghostscript execution failed: {e}")
        
        # Find generated plate files
        plate_files = sorted(plates_dir.glob("plate*.tif"))
        
        if not plate_files:
            raise GhostscriptError("No plate files generated by Ghostscript")
        
        logger.info(f"Generated {len(plate_files)} plate file(s)")
        
        # Rename plates based on their names (Ghostscript creates (Cyan), (Magenta), etc.)
        renamed_plates = self._rename_plates(plates_dir)
        
        return renamed_plates
    
    def _rename_plates(self, plates_dir: Path) -> List[Path]:
        """
        Rename Ghostscript plate files based on their actual plate names.
        Ghostscript tiffsep creates files like (Cyan).tif, (FOIL).tif, etc.
        
        Args:
            plates_dir: Directory containing plate files
            
        Returns:
            List of renamed plate paths
        """
        plates = []
        
        # Look for plates with parentheses names (standard tiffsep output)
        for plate_file in plates_dir.glob("*.tif"):
            plates.append(plate_file)
            logger.debug(f"Found plate: {plate_file.name}")
        
        return plates
    
    def convert_plates_to_png(self, plate_files: List[Path], 
                          output_dir: Path,
                          plate_mapping: Dict[str, str] = None,
                          expected_finish: str = None) -> Dict[str, Path]:
        """
        Convert Ghostscript plates (TIFF) → PNG and map to a finish.
        When expected_finish is set (single-finish PDF), ignore CMYK plates.
        """
        if plate_mapping is None:
            plate_mapping = config.PLATE_MAPPING

        output_dir.mkdir(parents=True, exist_ok=True)
        converted: Dict[str, Path] = {}

        for plate_file in sorted(plate_files):
            plate_name = plate_file.stem  # e.g. "(UV)" "(FOIL)" "(Cyan)" …

            # Spot plates (UV/FOIL/EMBOSS/DIE) → map to finish key
            finish = plate_mapping.get(plate_name)
            if finish:
                out_key = expected_finish if expected_finish else finish
                png_path = self._tiff_to_png(plate_file, output_dir, out_key)
                converted[out_key] = png_path
                continue

            # Process CMYK plates: only valid for albedo export
            if plate_name in config.PROCESS_PLATES:
                if expected_finish and expected_finish != "albedo":
                    # Effect PDFs should not produce CMYK plates; ignore with a warning
                    logger.warning(f"Unexpected process plate {plate_name} in {expected_finish} PDF")
                    continue
                # We don't build a CMYK composite here; tiffsep yields per-channel plates.
                # If you want to composite, do it later. For now we skip creating a PNG for each CMYK plate.
                continue

            logger.warning(f"Unknown plate from Ghostscript: {plate_name}")

        return converted
    
    def extract_and_convert_plates(pdf_path: Path, output_dir: Path, 
                               job_id: str,
                               expected_finishes: Optional[Dict[str, bool]] = None,
                               finish_type: str = None) -> Dict[str, Any]:
        extractor = PlateExtractor()
        plate_files = extractor.extract_plates(pdf_path, output_dir)

        errors = []
        if expected_finishes:
            errors = extractor.validate_plates(plate_files, expected_finishes)

        # ⬇ pass the hint so we name/output correctly per single-finish PDF
        converted = extractor.convert_plates_to_png(
            plate_files, output_dir, expected_finish=finish_type
        )

        plates_detected = [p.stem for p in plate_files]
        return {
            "success": len(errors) == 0,
            "plates_detected": plates_detected,
            "converted": converted,
            "errors": errors
        }

    
    def _tiff_to_png(self, tiff_path: Path, output_dir: Path, 
                     finish_type: str) -> Path:
        """
        Convert TIFF to PNG with proper formatting.
        Ensures white=apply, transparent background.
        
        Args:
            tiff_path: Input TIFF path
            output_dir: Output directory
            finish_type: Finish type (uv, foil, emboss, diecut_mask)
            
        Returns:
            Path to output PNG
        """
        # Open TIFF
        img = Image.open(tiff_path)
        
        # Convert to grayscale if needed
        if img.mode not in ['L', 'LA', 'RGBA', 'RGB']:
            img = img.convert('L')
        
        # Ensure we have RGBA for transparency
        if img.mode != 'RGBA':
            # Convert grayscale to RGBA
            # Invert: black in TIFF = white in output (apply)
            if img.mode == 'L':
                # Invert luminance: 0→255, 255→0
                import numpy as np
                arr = np.array(img)
                arr = 255 - arr  # Invert
                
                # Create RGBA: white where mask is, transparent elsewhere
                rgba = Image.new('RGBA', img.size)
                rgba_arr = np.array(rgba)
                rgba_arr[:, :, 0] = 255  # R
                rgba_arr[:, :, 1] = 255  # G
                rgba_arr[:, :, 2] = 255  # B
                rgba_arr[:, :, 3] = arr  # Alpha from inverted mask
                
                img = Image.fromarray(rgba_arr, 'RGBA')
        
        # Save as PNG
        output_filename = f"{finish_type}_temp.png"  # Temp name; will be renamed by app.py
        output_path = output_dir / output_filename
        
        img.save(output_path, 'PNG', optimize=True)
        
        return output_path
    
    def validate_plates(self, plate_files: List[Path], 
                       expected_finishes: Dict[str, bool]) -> List[str]:
        """
        Validate that expected plates were generated.
        
        Args:
            plate_files: List of generated plate paths
            expected_finishes: Dict of expected finishes (e.g., {"UV": True, "FOIL": True})
            
        Returns:
            List of error codes for missing plates
        """
        errors = []
        
        # Extract plate names
        plate_names = [p.stem for p in plate_files]
        
        # Check each expected finish
        for finish_type, expected in expected_finishes.items():
            if not expected:
                continue
            
            # Find corresponding plate name
            plate_name = f"({finish_type})"
            
            if plate_name not in plate_names:
                error_code = f"MISSING_PLATE_{finish_type}"
                errors.append(error_code)
                logger.error(f"Missing expected plate: {finish_type}")
        
        return errors
    
    def check_plate_luminance(self, png_path: Path) -> Tuple[int, int, int]:
        """
        Check plate PNG luminance statistics.
        
        Args:
            png_path: Path to PNG file
            
        Returns:
            Tuple of (min_luminance, max_luminance, non_transparent_pixels)
        """
        img = Image.open(png_path)
        
        if img.mode != 'RGBA':
            img = img.convert('RGBA')
        
        import numpy as np
        arr = np.array(img)
        
        # Get alpha channel
        alpha = arr[:, :, 3]
        
        # Count non-transparent pixels
        non_transparent = np.count_nonzero(alpha > 0)
        
        # Get RGB channels where alpha > 0
        mask = alpha > 0
        if non_transparent > 0:
            rgb = arr[:, :, :3]
            luminance = (0.299 * rgb[:, :, 0] + 0.587 * rgb[:, :, 1] + 0.114 * rgb[:, :, 2])
            masked_luminance = luminance[mask]
            
            min_lum = int(np.min(masked_luminance))
            max_lum = int(np.max(masked_luminance))
        else:
            min_lum = 0
            max_lum = 0
        
        return min_lum, max_lum, non_transparent


def extract_and_convert_plates(pdf_path: Path, output_dir: Path, 
                               job_id: str,
                               expected_finishes: Optional[Dict[str, bool]] = None,
                               finish_type: str = None) -> Dict[str, Any]:
    """
    Convenience function to extract plates and convert to PNG (single PDF input).
    finish_type: lowercased finish hint ("albedo","uv","foil","emboss","die"|"diecut_mask")
    """
    extractor = PlateExtractor()

    # Extract plates with tiffsep
    plate_files = extractor.extract_plates(pdf_path, output_dir)

    # Optional validation (usually skipped for single-finish PDFs)
    errors = []
    if expected_finishes:
        errors = extractor.validate_plates(plate_files, expected_finishes)

    # Convert to PNGs; for single-finish PDFs, map any spot to that finish
    converted = extractor.convert_plates_to_png(
        plate_files, output_dir, expected_finish=finish_type
    )

    plates_detected = [p.stem for p in plate_files]
    return {
        "success": len(errors) == 0,
        "plates_detected": plates_detected,
        "converted": converted,
        "errors": errors
    }

